---
sidebar_position: 1
---

# AVM Execution and State Model

## Triggering execution
An instance of the AVM processes a public execution request. A transaction may include multiple such requests ([`enqueuedPublicFunctionCalls`](../calls/enqueued-calls.md)) which a Sequencer will process via entirely separate instances of the AVM.

The Sequencer uses the execution request (calldata in particular) and its specified contract address to initialize the VM's inputs. Once these inputs are prepared, the VM can perform "Request Execution" starting with "Call Execution" for the request's initial call.

## Public Contract Bytecode
The contract address specified in a public execution request is used by the Sequencer to retrieve the corresponding contract bytecode along with its commitment (generated during contract deployment via the [Bytecode Validation Circuit](./bytecode-validation-circuit.md)). A contract's bytecode provides the VM with execution instructions, while the bytecode commitment serves as a key for verification of execution proofs generated by the circuit implementation of the VM.

The entirety of a contract's public code exists in a single bytecode. While a Noir contract may have multiple public functions, they are compiled into a single bytecode. Internal calls to Noir functions within the same contract are simple program-counter changes. In a manner similar to the Ethereum Virtual Machine, the AVM is not itself aware of function selectors and internal function calls. In a similar manner to the Solidity compiler, the Noir compiler may implement these constructs by treating the first word of calldata as a function selector, and beginning a contract's bytecode with a series of conditional jumps.

## VM Inputs, State, Outputs
We define "context" here to be the information that triggers some level of execution. When the VM "executes a context", it performs execution given that context as input. For example, a "RequestContext" refers to the information relating to a public execution request. It does not change during its execution as it is meant to represent the context that triggered that execution.

The following data structures must be initialized before execution can begin:
- `BlockInfo`:  information that remains constant for all transactions in a block, but may change from one block to the next.
    ```
    BlockInfo {
        timestamp,
        blockNumber,
        chainId,
        version,
        roots,
    }
    ```
- `TxContext`: derived from a transaction request. Constant for the entirety of a transaction (throughout execution of all of a transaction's public execution requests), but may change from one transaction to the next.
    - examples: txL1GasLimit, txL2GasLimit, origin, ...
    ```
    TxContext {
        origin,
        txL1GasLimit,
        txL2GasLimit,
    }
    ```
- `RequestContext`: derived from a single public execution request. Constant for the entirety of a request's (throughout all nested calls), but may change from one request to the next.
    ```
    RequestContext {
        sender,
        requestL1GasLimit,
        requestL2GasLimit,
    }
    ```
- `CallContext`: derived from a single public call. Constant for the entirety of a public call. This does not change from one instruction to the next within the same call, but differs for each nested call in a public execution request.
    ```
    CallContext {
        sender,
        address,
        callL1GasLimit,
        callL2GasLimit,
        calldata,
    }
    ```

The following state is maintained by the VM and updated on a per-instruction basis:
- `CallState`: internal call state that does not persist outside of the context of the current call.
    ```
    CallState {
        error,
        pc,
        l1GasUsed,
        l2GasUsed,
        memory,
    }
    ```
- Persistable state: state (siloed per-contract) that can persist throughout all calls in a request. When a call returns successfully, its updates to this state persist to the caller. When a call reverts, all of its persistable state changes are reverted (including those made by nested calls).
    - Examples: Storage, Nullifiers, Note Hashes, L2->L2 messages
    > In VM's high-level architecture, these state updates simply persist after a call completes. At the circuit level, state updates are tracked alongside state accesses via a "trace" which becomes an output of the circuit to be validated by the public kernel. When a call reverts, its trace and the traces of its nested calls are flagged as "reverted" and therefore they do not persist in the calling context.

When execution of a call ends, the following `CallResults` are communicated to the caller:
```
CallResults {
    success,
    returndata,
    l1GasUsed,
    l2GasUsed,
}
```

The caller consumes a nested call's results to update its own `CallState`.

## Call Execution
Each VM opcode defines a state transition function on the VM's `CallState`. Some instructions trigger an update to the VM's persistable state. When a call returns or reverts, this uses the `CallState` to return `CallResults` to the caller. An instruction's inputs (offsets, or immediates) change what state is modified and/or how. The details of all supported VM operations are elaborated on in the [Instruction Set document](./InstructionSet).

### CallState initialization
For execution of any call, `CallState` is initialized as follows:
```
CallState {
    pc = 0
    l1GasUsed = 0
    l2GasUsed = 0
    memory = uninitialized
}
```
> Note: an uninitialized memory cell cannot be read. Unlike the EVM, a word in memory must be explicitly `SET` before it can be read.

### Program Counter
Most instructions increment the `CallState`'s program counter by 1. This allows VM execution to proceed from instruction to instruction. Some instructions (`JUMP`, `JUMPI`) modify the program counter (PC) based on inputs. A call's execution always starts at program counter 0, and each instruction's transition function determines the next instruction to execute.

### Gas
Each instruction has an associated `l1GasCost` and `l2GasCost`. Before an instruction is executed, the VM enforces that there is sufficient gas remaining via the following assertions:
```
assert l1GasCost + CallState.l1GasUsed <= CallContext.callL1GasLimit 
assert l2GasCost + CallState.l2GasUsed <= CallContext.callL2GasLimit 
```

If these assertions pass, the following state transition occurs prior to the instruction's core execution:
```
CallContext.l1GasUsed += l1GasCost
CallContext.l2GasUsed += l2GasCost
```

> Note: the fact that this state transition occurs prior to the instruction's core execution allows the [`L1GAS` and `L2GAS`](./InstructionSet/#isa-section-l1gas) instructions to return the gas remaining _after accounting for the current instruction's cost_.

If these assertions _fail_ for an instruction, the current call is reverted and its execution ends. Reverting will be covered in more detail later.

#### Gas cost examples
- The cost of an instruction increases for each of its "offset" arguments that is flagged as "indirect"
- `JUMP` has constant gas cost
- `SET`'s gas cost changes with its `dst-type`
- Instructions that operate on a variable data size (like `CALLDATACOPY`) scale in cost with that size (`copySize` argument in the case of `CALLDATACOPY`)
- The `CALL` instruction's gas cost is determined by its `l*Gas` arguments, but any gas unused by the nested call is refunded after it completes (more on this later)

> Implementation detail: an instruction's gas cost will align with the number of rows it corresponds to in the execution trace including rows of the suboperation table and memory table.

### Nested calls

If the above assertions pass, execution is triggered in the called contract with a new `CallContext` and an initial `CallState`. `BlockInfo`, `TxContext`, and `RequestContext` remain the same. The new `CallContext` is initialized as follows:

```
CallContext {  // nested
    callL1GasLimit = l1Gas // from `gasOffset` argument
    callL2GasLimit = l2Gas // from `gasOffset+1` argument
    sender = addr          // from `addrOffset` argument
    calldata = args        // from `argsOffset` argument
}
```

Execution proceeds in the callee's context with a fresh `CallState`.

### Returning and reverting
Execution of a call ends if any one of the following conditions are met:
1. A [`RETURN` instruction](./InstructionSet/#isa-section-return) is encountered
2. A [`REVERT` instruction](./InstructionSet/#isa-section-revert) is encountered
3. An instruction has reverted for any reason (like out-of-gas)

In the case of conditions 1 or 2, data can optionally be returned to the calling context (via the `retOffset` and `retSize` arguments to `RETURN` or `REVERT`). In the calling context, returned data from a nested call is placed into memory according to the `retOffset` and `retSize` arguments to the [`CALL` instruction](./InstructionSet/#isa-section-call).

#### Gas cost and refunds for nested calls
For any of the above cases, any gas unused (`l*GasUnused = CallContext.callL*GasLimit - CallState.l*GasUsed`) when a call ends is returned to the caller. The caller processes this as a refund as follows:
```
CallState.l1GasUsed -= l1GasUnused
CallState.l2GasUsed -= l2GasUnused
```

Via these gas tracking and refund mechanisms, a call's final `l*GasUsed` represents all gas used by its instructions **including gas used by nested calls**. Therefore, the final `CallContext` of the initial call of a "Request Execution" is the total gas used by the entire request.

> OLD: The `CALL` instruction is another example with a more complex computed gas cost computation. This instruction makes a nested call to another contract, providing the callee with a maximum gas allocation (via the `l1Gas` and `l2Gas` arguments). **A nested call's gas allocation must be less than current call's remaining gas!** That gas allocation is the `l*GasCost` of the instruction and is added to `CallContext.l*GasUsed`, but with an important caveat: if the nested call does not use up its entire gas allocation, any remaining gas is refunded to the caller and subtracted from `Context.l*GasUsed` as the instruction finishes.


> TODO: will an instruction use more gas if its offsets are flagged as indirect?
> TODO: will SET use a different amount of gas based on its `in-tag`/size?
> TODO: should a storage read or write use less gas if that slot has already been read/written previously in the same transaction? If so, how can we accomplish this?
- Should sideeffects from execution thus far become an input to nested calls?
    - An `SLOAD` of a slot previously read could then directly access a sideeffect from its inputs if present instead of retrieving the an entry from the public data tree 
    - And should an `SLOAD` be able to optionally lookup an entry from `CallState.sideEffects` instead of retrieving it externally and pushing it again to the sideEffects array?
    - **Is it cheaper to do this? The VM is creating less public inputs but its relations may be substantially more complex?**
    - Is this a deep implementation detail not necessary to expose at this level?
- Could the VM handle state transition and other side-effect ordering? Private circuits can't because we don't trust them. But I think the VM maybe could, although it would require each nested call's circuit to accept as public inputs all side-effects thus far.
    - A VM call/circuit would accept all side-effects thus far as an input. It would also track its own side-effects.
    - **Let's consider public state first**
        - Side-note: it may still be preferrable to be able to rely on the Public VM to have ordered size effects even if squashing isn't performed until the kernel! But this means that input size of the PublicVM grows pretty quickly.
        - The VM can track its own storage mapping from `slot>value`
        - A call creates side-effects (reads/writes some storage slots) and when it completes, it returns that information to its caller.
        - Caller sees that a nested call created some side-effects and updates its own side-effects list accordingly. I think the only side-effects that are directly relevant to the Caller are those that may have come from further nested calls into the same contract as the caller.
        - So, maybe the caller only updates its CallState.sideEffects with sideEffects from the nested call that match the caller's address. Any subsequent state accesses by the caller will reference this updated state first.
        - If the databus makes this feasible, then it miht be preferrable
        - **But we are moving computation from the public kernel to a more expensive VM!** But we are also removing the need to do sideEffect reordering....
        - So what would the additional computation be in the VM? First off each circuit would have additional inputs. The kernel would not need to validate them since we can trust that the VM is generating proper inputs here. We only need to validate EXTERNAL STATE READS. Reads of state that could remain internal (reading a value from CallContext.sideEffects orCallState.sideEffects) do not require external validation. In fact, reads like this shouldn't even need to be output via sideEffects as they are no different from a read of msgSender from CallContext. 
        - State-writes could either ALWAYS be output to sideEffects, or the VM could squash writes to previously written slots. Squashing would require some painful array collapsing within the VM, but the VM could alternatively just flag old entries as squashed and leave them there.
        - Each SLOAD will either perform a lookup into CallState.sideEffects OR retrieve external data from the state tree. **Is this possible? Would it require that the SLOAD operation have different suboperations based on the context, and is this feasible?**
            - How will a lookup into sideEffects be performed? Would it essentially be another memory table?
            - A nested call's sideEffects would be iterated over by the SLOAD instructionand all entries matching the current contract address would be loaded into the storage table. Any entries that do not match the current contract address would just be copied to the call's outputs.
            - At the end of a call, the final key-value storage map is appended to the output


### Nested Calls

> TODO: Maximum nested calls per call?

A execution request triggers an initial "call" to the VM. That call may make further nested calls to other contracts.

> Implementation detail: certain arrays like calldata, returndata and state accesses may be implemented as separate VM columns and therefore will not technically be grouped with simpler context and state fields. Regardless, it is useful to categorize them as is done so above.
> Implementation detail: the context and state objects are public inputs to the VM circuit, but the bytecode is actually not an input! A contract's public bytecode serves as its verification key. Bytecode is loaded into a lookup table, and a VM column is dedicated instruction retrieval by program counter. It is then part of the verifier algorithm to ensure that the instruction column matches the contract's bytecode commitment.

Each contract call within a transaction

The VM processes one instruction at a time, updating state for each instruction. VM state is categorized as follows:

> Note: one public kernel sequence exists for each public execution request in a transaction. If a transaction includes multiple such requests (_e.g._ multiple public calls are enqueued by private execution), multiple separate public kernel sequences must be triggered, each of which will generate a separate public kernel proof.
