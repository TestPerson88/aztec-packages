---
sidebar_position: 1
---

# AVM Execution
Given a contract's bytecode (instructions) and an initial execution "context", AVM execution is the stepwise application of each instruction's transition function to that context until it returns or reverts. Each instruction's transition function is detailed in the [AVM Instruction Set](./InstructionSet).

AVM execution is performed separately for each of a transaction's public execution requests ([`enqueuedPublicFunctionCalls`](../calls/enqueued-calls.md)).

## Public Contract Bytecode
The contract address specified in a public execution request can be used to retrieve the corresponding contract bytecode along with its commitment (generated during contract deployment via the [Bytecode Validation Circuit](./bytecode-validation-circuit.md)). A contract's bytecode provides the VM with execution instructions, while the bytecode commitment serves as a key for verification of execution proofs generated by the circuit implementation of the VM.

The entirety of a contract's public code exists in a single bytecode. While a Noir contract may have multiple public functions, they are compiled into a single bytecode. Internal calls to Noir functions within the same contract are simple program-counter changes. In a manner similar to the Ethereum Virtual Machine, the AVM is not itself aware of function selectors and internal function calls. In a similar manner to the Solidity compiler, the Noir compiler may implement these constructs by treating the first word of calldata as a function selector, and beginning a contract's bytecode with a series of conditional jumps.

## Execution Contexts

Given a `PublicCallRequest` and its `CallContext` (different from AVM context), an `AVMContext` is initialized as follows:
```
AVMContext {
    // Initial
    block: BlockHeader & GlobalVariables,
    origin: TxRequest.origin,
    sender: PublicCallRequest.CallContext.msgSender,
    address: PublicCallRequest.contractAddress,
    portal: PublicCallRequest.CallContext.portalContractAddress,
    l1GasLimit: PublicCallRequest.CallContext.l1GasLimit,
    l2GasLimit: PublicCallRequest.CallContext.l2GasLimit,
    calldata: PublicCallRequest.args,
    isStaticCall: PublicCallRequest.CallContext.isStaticCall,

    // State
    pc: 0,
    memory: uninitialized,
    error: 0,
    l1GasUsed: 0,
    l2GasUsed: 0,
    persistableStateTrace: empty,
    returndata: empty,
}
```

The first few context fields are initialized during the context's creation and are not modified throughout the AVM's execution of _this_ context. The last few fields represent "state" that will be incrementally transformed by each instruction processed during this context's execution.

When a context's execution ends (returns or reverts), the above structure's last few fields are captured into the following execution outputs:
```
ContextOutputs {
    error,
    l1GasUsed,
    l2GasUsed,
    persistableStateTrace,
    returndata,
}
```

TODO: briefly mention sub-contexts and nested calls which are elaborated on later
TODO: consider scrapping `ContextOutputs` and just saying "sub-context is communicated to caller"
- How should return be handled?

Each instruction defines the transition function it will apply to the current context. An instruction's inputs (offsets, or immediates) tweak exactly how it will transform the context. The details of all supported operations are detailed in the [AVM Instruction Set](./InstructionSet).

## Program Counter and Control Flow
The context's program counter (`pc`) is an index into the contract's public bytecode. A context's execution always starts at program counter 0, and each instruction's transition function updates the program counter in some way.

Most instructions simply increment the context's program counter by 1. This allows VM execution to flow naturally from instruction to instruction. Some instructions ([`JUMP`](./InstructionSet#isa-section-jump), [`JUMPI`](./InstructionSet#isa-section-jumpi)) modify the program counter based on inputs.

## Gas limits and tracking
Each instruction has an associated `l1GasCost` and `l2GasCost`. Before an instruction is executed, the VM enforces that there is sufficient gas remaining via the following assertions:
```
assert l1GasCost + context.l1GasUsed <= context.l1GasLimit
assert l2GasCost + context.l2GasUsed <= context.l2GasLimit
```

If these assertions pass, the following state transition occurs prior to the instruction's core execution:
```
context.l1GasUsed += l1GasCost
context.l2GasUsed += l2GasCost
```

> The fact that this state transition occurs prior to the instruction's core execution allows the [`L1GAS` and `L2GAS`](./InstructionSet/#isa-section-l1gas) instructions to return the gas remaining _after accounting for the current instruction's cost_.

If these assertions _fail_ for an instruction, the following state transition occurs before the context's execution reverts:
```
context.l1GasUsed = context.l1GasLimit
context.l2GasUsed = context.l2GasLimit
```
> Reverting will be covered in more detail later.

### Gas cost examples
- The cost of an instruction increases for each of its "offset" arguments that is flagged as "indirect"
- `JUMP` has constant gas cost
- `SET`'s gas cost changes with its `dst-type`
- Instructions that operate on a variable data size (like `CALLDATACOPY`) scale in cost with that size (`copySize` argument in the case of `CALLDATACOPY`)
- The `CALL` instruction's gas cost is determined by its `l*Gas` arguments, but any gas unused by the sub-context is refunded after it completes (more on this later)
- If an instruction reverts, its cost is `L*GAS_COST_OF_REVERT`

> Implementation detail: an instruction's gas cost will align with the number of rows it corresponds to in the VM execution trace including rows of the sub-operation table and memory table.

## Halting
A context's execution halts if any of the following conditions are met:
1. A [`RETURN` instruction](./InstructionSet/#isa-section-return) is encountered
2. A [`REVERT` instruction](./InstructionSet/#isa-section-revert) is encountered
3. An instruction has reverted for any reason (_e.g._ out-of-gas)

For cases 1 and 2, data can optionally be returned to the calling context (more on this later).

For cases 2 and 3, the context's error flag is raised (`context.error = 1`).

As mentioned previously, when a context's execution ends, its results are captured in `ContextOutputs`.

## Nested calls, sub-contexts, and returning data
A contract can make a nested call to another via the `CALL` or `STATICCALL` instruction:
```
// CALL gasOffset argsOffset argsSize retOffset retSize successOffset
M[successOffset] = call(
    M[gasOffset], M[gasOffset+1], M[addrOffset],
    M[argsOffset], M[argsSize],
    M[retOffset], M[retSize])
```
> See the [Instruction Set's descriptions](./InstructionSet/#isa-section-call) of the `CALL` and `STATICCALL` instructions for details on their arguments.

When a nested call is made to another contract, a sub-context (`subContext`) is derived as follows from the current/parent context (`context`) and the `[STATIC]CALL` instruction's arguments:
```
subContext = AVMContext {
    block: context.block,
    origin: context.origin,
    address: context.memory[addrOffset], // arg to CALL instruction
    sender: context.address,
    portal: <retrieved from contracts tree>,
    l1GasLimit: context.memory[gasOffset], // arg to CALL instruction
    l2GasLimit: context.memory[gasOffset+1], // arg to CALL instruction
    calldata: context.memory[argsOffset:argsOffset+argsSize], // args to CALL instruction
    isStaticCall: <created by `STATICCALL` instruction?>,

    // State
    pc: 0,
    memory: uninitialized,
    error: 0,
    l1GasUsed: 0,
    l2GasUsed: 0,
    persistableStateTrace: empty,
    returndata: empty,
}
```
> `context.memory[offset]` here is equivalent to the `M[offset]` syntax used in the instruction set.

A sub-context executes until it returns or reverts. Execution can be explicitly terminated by the bytecode via the `RETURN` and `REVERT` instruction. These instructions can optionally return some data from memory to the caller:
```
// RETURN retOffset retSize
subContext.returndata = M[retOffset:retOffset+retSize]
// ... halt

// REVERT retOffset retSize
subContext.error = 1
subContext.returndata = M[retOffset:retOffset+retSize]
// ... halt
```
> A sub-context does not call itself `subContext`. This term is used above only to make it clear that this discussion is about a sub-context's execution completing, but in reality a sub-context just calls itself `context`.

Now that sub-context execution has halted, results are communicated to the parent context where execution resumes. `[STATIC]CALL`'s transition function includes the following:
```
context.memory[successOffset] = subContext.error
// refund unused gas
context.l1GasUsed -= subContext.l1GasLimit - subContext.l1GasUsed
context.l2GasUsed -= subContext.l2GasLimit - subContext.l2GasUsed
// accept persistable state changes unless sub-context reverted
if !subContext.error: context.persistableStateTrace.append(subContext.persistableStateTrace)
context.memory[retOffset:retOffset+retSize] = subContext.returndata[0:retSize]
// ... proceed with execution
```

> A context's `ContextOutputs.l*GasUsed` represents all gas used by its instructions **including gas used by nested calls**. Therefore, the `ContextOutputs.l*GasUsed` of a public execution request's initial call is the total gas used during the request's execution.

Contexts run in isolated environments with information transfer between context and sub-context limited to the mechanisms described above.

## TODO

- output returndata to kernel?
- Persistable state: state (siloed per-contract) that can persist throughout all calls in a request. When a call returns successfully, its updates to this state persist to the caller. When a call reverts, all of its persistable state changes are reverted (including those made by nested calls).
    - Examples: Storage, Nullifiers, Note Hashes, L2->L2 messages
    > In VM's high-level architecture, these state updates simply persist after a call completes. At the circuit level, state updates are tracked alongside state accesses via a "trace" which becomes an output of the circuit to be validated by the public kernel. When a call reverts, its trace and the traces of its nested calls are flagged as "reverted" and therefore they do not persist in the calling context.

> OLD: The `CALL` instruction is another example with a more complex computed gas cost computation. This instruction makes a nested call to another contract, providing the callee with a maximum gas allocation (via the `l1Gas` and `l2Gas` arguments). **A nested call's gas allocation must be less than current call's remaining gas!** That gas allocation is the `l*GasCost` of the instruction and is added to `CallContext.l*GasUsed`, but with an important caveat: if the nested call does not use up its entire gas allocation, any remaining gas is refunded to the caller and subtracted from `Context.l*GasUsed` as the instruction finishes.


> TODO: will an instruction use more gas if its offsets are flagged as indirect?
> TODO: will SET use a different amount of gas based on its `in-tag`/size?
> TODO: should a storage read or write use less gas if that slot has already been read/written previously in the same transaction? If so, how can we accomplish this?
- Should sideeffects from execution thus far become an input to nested calls?
    - An `SLOAD` of a slot previously read could then directly access a sideeffect from its inputs if present instead of retrieving the an entry from the public data tree 
    - And should an `SLOAD` be able to optionally lookup an entry from `CallState.sideEffects` instead of retrieving it externally and pushing it again to the sideEffects array?
    - **Is it cheaper to do this? The VM is creating less public inputs but its relations may be substantially more complex?**
    - Is this a deep implementation detail not necessary to expose at this level?
- Could the VM handle state transition and other side-effect ordering? Private circuits can't because we don't trust them. But I think the VM maybe could, although it would require each nested call's circuit to accept as public inputs all side-effects thus far.
    - A VM call/circuit would accept all side-effects thus far as an input. It would also track its own side-effects.
    - **Let's consider public state first**
        - Side-note: it may still be preferrable to be able to rely on the Public VM to have ordered size effects even if squashing isn't performed until the kernel! But this means that input size of the PublicVM grows pretty quickly.
        - The VM can track its own storage mapping from `slot>value`
        - A call creates side-effects (reads/writes some storage slots) and when it completes, it returns that information to its caller.
        - Caller sees that a nested call created some side-effects and updates its own side-effects list accordingly. I think the only side-effects that are directly relevant to the Caller are those that may have come from further nested calls into the same contract as the caller.
        - So, maybe the caller only updates its CallState.sideEffects with sideEffects from the nested call that match the caller's address. Any subsequent state accesses by the caller will reference this updated state first.
        - If the databus makes this feasible, then it miht be preferrable
        - **But we are moving computation from the public kernel to a more expensive VM!** But we are also removing the need to do sideEffect reordering....
        - So what would the additional computation be in the VM? First off each circuit would have additional inputs. The kernel would not need to validate them since we can trust that the VM is generating proper inputs here. We only need to validate EXTERNAL STATE READS. Reads of state that could remain internal (reading a value from CallContext.sideEffects orCallState.sideEffects) do not require external validation. In fact, reads like this shouldn't even need to be output via sideEffects as they are no different from a read of msgSender from CallContext. 
        - State-writes could either ALWAYS be output to sideEffects, or the VM could squash writes to previously written slots. Squashing would require some painful array collapsing within the VM, but the VM could alternatively just flag old entries as squashed and leave them there.
        - Each SLOAD will either perform a lookup into CallState.sideEffects OR retrieve external data from the state tree. **Is this possible? Would it require that the SLOAD operation have different suboperations based on the context, and is this feasible?**
            - How will a lookup into sideEffects be performed? Would it essentially be another memory table?
            - A nested call's sideEffects would be iterated over by the SLOAD instructionand all entries matching the current contract address would be loaded into the storage table. Any entries that do not match the current contract address would just be copied to the call's outputs.
            - At the end of a call, the final key-value storage map is appended to the output


> TODO: Maximum nested calls per call?
> TODO: does the VM need to aggregate nested calls
> TODO: Does the kernel need to check callstack ordering like it does for private?

> Implementation detail: certain arrays like calldata, returndata and state accesses may be implemented as separate VM columns and therefore will not technically be grouped with simpler context and state fields. Regardless, it is useful to categorize them as is done so above.
> Implementation detail: the context and state objects are public inputs to the VM circuit, but the bytecode is actually not an input! A contract's public bytecode serves as its verification key. Bytecode is loaded into a lookup table, and a VM column is dedicated instruction retrieval by program counter. It is then part of the verifier algorithm to ensure that the instruction column matches the contract's bytecode commitment.

Each contract call within a transaction

The VM processes one instruction at a time, updating state for each instruction. VM state is categorized as follows:

> Note: one public kernel sequence exists for each public execution request in a transaction. If a transaction includes multiple such requests (_e.g._ multiple public calls are enqueued by private execution), multiple separate public kernel sequences must be triggered, each of which will generate a separate public kernel proof.
